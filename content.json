[{"title":"es6笔记1","date":"2018-01-23T16:55:48.000Z","path":"2018/01/24/es6笔记1/","text":"es6可以参考阮一峰的教程，介绍了es6的编译方法和es6的语法，阮一峰：《ECMAScript 6 入门》 1.let和constes6新增用let声明变量，有如下的特点：(1)使用let声明的变量不能重复定义，下面这样的定义方式是不允许的12let a = 1;let a = 2; (2)声明的变量只在let命令所在的代码块内有效，简单的理解就是用{}包起来的作用域有效123456789function fun()&#123; for(let i=0;i&lt;5;i++)&#123; console.log(i) &#125; // 这里输出的时候会报错，可以理解为i的生命周期结束了 // 块级作用域之外无效 console.log(i)&#125;fun() (3)let声明的变量不存在变量提升,在定义之前使用报错：ReferenceError const:（1）用于声明一个常量,声明的常量不可以重复声明（2）声明的时候必须赋值，以下的情况会报错：12const PI;pI= 3.14 (3)const声明的也是有块级作用域的，在外面使用的时候会报错123456789function test()&#123; for(let i=0;i&lt;4;i++)&#123; const aa = '这是aa的值' &#125; // 下面的都会报错 console.log(i) console.log(aa)&#125;test() （4）const声明的对象的值可以改变，12345678910function test2()&#123; // 对象是引用类型的，k存储的是指针，对象本身是可以改变的 const k=&#123; a:1 &#125; k.b =3 //这里不会报错 console.log(k)&#125;test2() 2.解构赋值概念：解构赋值其实就是赋值，左边的对应右边的，一一对应进行赋值解构赋值的分类：（1）数组解构赋值（2）对象解构赋值（3）字符串解构赋值（4）布尔值解构赋值（5） 函数参数解构赋值（6）数值解构赋值需要重点理解的是数组结构赋值和对象解构赋值 数组解构赋值：1234567891011&#123; let a,b ,rest [a,b,...rest] = [1,2,3,4,5,6]; console.log(a,b,rest) //1 2 [3,4,5,6]&#125;&#123; let a,b,c,rest [a,b,c] =[1,2] // 没有找到配对的输出undefined console.log(a,b,c) //1 2 undefined&#125; 对象解构赋值：12345&#123; let a,b (&#123;a,b&#125; = &#123;a:1,b:2&#125;) console.log(a,b) // 1 2 &#125; 3.使用场景12345678910111213141516// 1、简单实现值的交换&#123; let a = 1; let b = 2; [a,b] = [b,a] console.log(a,b) 2,1&#125;//2、 获取返回的值&#123; function fun()&#123; return [1,2] &#125; let a,b [a,b] = fun() console.log(a,b)&#125; 1234567891011121314151617181920212223// 对象解构赋值的2边都是对象的形式// 按照 key value 的形式匹配&#123; let o = &#123;q:1,p:2&#125; let &#123;q,p&#125; = o; console.log(q,p)&#125;// 嵌套取值&#123; let testData = &#123; title:'es6', test:[&#123; title:'es7', desc:'descript' &#125;] &#125; let &#123;title:esTitle,test:[&#123;title:cntitle&#125;]&#125; = testData console.log(esTitle,cntitle) //es6 es7 let &#123;title&#125; = testData console.log(title) // es6 let [test] = testData.test console.log(test.title) //es7&#125;","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vue项目使用express发送数据","date":"2018-01-22T16:44:39.000Z","path":"2018/01/23/vue项目使用express发送数据/","text":"之前使用vue-cli生成的项目中，是有express依赖的，后来的没有了，那怎样用express发送数据呢？研究了一下，实现的过程并不难 实现的过程如下：1.在生成的vue项目下，新建server文件夹，在server文件夹下，执行命令：123$ npm init$ cnpm install$ cnpm install express --save 2.在vue项目的根目录中放入需要的数据文件，我使用的datas.json文件3.在server文件夹下新建server.js文件：server.js123456789101112131415161718192021222324252627var appData = require(&apos;../datas.json&apos;)var list1 = appData.list1;var list2 = appData.list2;const express = require(&apos;express&apos;)const app = express()const apiRoutes = express.Router();apiRoutes.get(&apos;/list1&apos;,function(req,res)&#123; res.json(&#123; code:0, data:list1 &#125;);&#125;);apiRoutes.get(&apos;/list2&apos;,function(req,res)&#123; res.json(&#123; code:0, data:list2 &#125;);&#125;);app.use(&apos;/api&apos;,apiRoutes);app.listen(3000,function()&#123; console.log(&apos;server start&apos;);&#125;);4.在config文件夹下的index.js中设置代理：index.js12345678proxyTable: &#123; &apos;/api/list1&apos;:&#123; target:&apos;http://localhost:3000&apos; &#125;, &apos;/api/list2&apos;:&#123; target:&apos;http://localhost:3000&apos; &#125; &#125;,5.在server文件夹下执行：1node server.js完成前面的步骤，在vue项目中就可以使用axios请求数据了，如下：12345678910methods: &#123; getList1()&#123; axios.get(&apos;/api/list1&apos;).then((res) =&gt; &#123; if(res.data.code === 0)&#123; this.list1 = res.data.data console.log(this.list1) &#125; &#125;) &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"三栏布局的几种实现方式","date":"2018-01-22T15:41:02.000Z","path":"2018/01/22/三栏布局的几种实现方式/","text":"在高度已经知道的情况下，实现三栏布局，左栏、右栏的宽度为350px,中间自适应,以及各种布局优缺点实现的效果图如下： 浮动的方式123456789101112131415161718192021222324252627/*css部分*/&#123; margin: 0; padding: 0;&#125;.left-center-right div&#123; min-height: 100px;&#125;.left-center-right .left&#123; float: left; width: 350px; background-color: red;&#125;.left-center-right .center&#123; background-color: green;&#125;.left-center-right .right&#123; background-color: blue; float: right; width: 350px;&#125;&lt;!-- 注意，此处的排列为left right center --&gt;&lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;左边部分&lt;/div&gt; &lt;div class=\"right\"&gt;右边部分&lt;/div&gt; &lt;div class=\"center\"&gt;中间部分&lt;/div&gt;&lt;/div&gt; 优点：兼容性好缺点：浮动的元素脱离标准流，需要清除浮动，处理不好就尴尬了 定位的方式123456789101112131415161718192021222324.left-center-right div&#123; min-height: 100px; position: absolute;&#125;.left-center-right .left&#123; left:0; width: 350px; background-color: red;&#125;.left-center-right .center&#123; left: 350px; right: 350px; background-color: green;&#125;.left-center-right .right&#123; right:0; background-color: blue; width: 350px;&#125;&lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;左边部分&lt;/div&gt; &lt;div class=\"right\"&gt;右边部分&lt;/div&gt; &lt;div class=\"center\"&gt;中间部分&lt;/div&gt;&lt;/div&gt; 优点：快速实现布局缺点：绝对定位的元素脱离标准流，子元素也需要脱离标准流，使用性比较差 flex布局的方式.left-right-center{ display: flex; } .left-right-center div{ min-height: 100px; } .left-right-center .left{ width: 300px; background-color: red; } .left-right-center .center{ flex:1; right: 300px; background-color: green; } .left-right-center .right{ width: 300px; background-color: blue; } 优点：css3的布局方式，可以简单的实现各种页面的响应式布局，特别是在移动端缺点： 表格布局的方式.left-right-center{ width:100%; display: table; height: 100px; } .left-right-center div{ display: table-cell; } .left{ width: 350px; background-color: red; } .center{ right: 350px; background-color: green; } .right{ background-color: blue; width: 300px; } 优点：实现简单，兼容性好缺点：一个高度变化的时候其他的也会撑高","tags":[{"name":"html/css","slug":"html-css","permalink":"http://yoursite.com/tags/html-css/"}]}]