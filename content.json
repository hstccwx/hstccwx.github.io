[{"title":"jqeury基础","date":"2018-02-21T03:11:07.000Z","path":"2018/02/21/jqeury基础/","text":"jQuery是一个快速、简洁的JavaScript框架。封装了开发过程中常用的一些功能，提高了开发的效率 1、使用步骤：（1）引入jquery（2）写入口函数（3）编写事件处理函数123456789101112&lt;!-- 1、引入jquery --&gt;&lt;script src=\"jquery-3.3.1.js\"&gt;&lt;/script&gt; &lt;script&gt; // 2、写入口函数 $(document).ready(function()&#123; // 3、写事件处理函数 $(\"#box\").click(function()&#123; alert(\"这里开始写事件处理函数\") &#125;) &#125;);&lt;/script&gt; 备注：jquery入口函数和javascript函数的区别：（1）javascript入口函数只出现一次，多次出现的时候，后面的事件覆盖前面的事件 jquery入口函数，可以出现多次，不存在事件覆盖问题（2）Js入口函数是在所有的文件资源加载完成后，才执行。这些文件资源包括：页面文档、外部的js文件、外部的css文件、图片等 jQuery的入口函数，是在文档加载完成后，就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成 2、jquery对象和DOM对象(js操作返回)的相互转换: jquery对象指的是：使用jquery提供的操作DOM的方法返回的结果，其实就是对DOM进行了封装，让获取的对象具有jquery的方法 （1）DOM对象转换成jQuery对象： var $btn = $(“#btn”); // DOM对象btn转换成了jQuery对象$btn $(document).ready(function(){}); // 调用入口函数 此处是将document这个js的DOM对象，转换成了jQuery对象，然后才能调用jQuery提供的方法：ready （2）jQuery对象转换成DOM对象：// 方式1var btn1 = $btn[0];// 方式2:var btn2 = $btn.get(0); 3、选择器：jQuery实现了从CSS1到CSS3所有的选择器以及其他常用的选择器。 具体的参照API文档 4、实际案例：（1）实现简单的手风琴效果，使用链式调用12345678910111213141516171819202122&lt;script src=&quot;jquery-3.3.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(function () &#123; $(&quot;.parentWrap span&quot;).click(function () &#123; $(this).next().show().parent(&quot;li&quot;).siblings(&quot;li&quot;).find(&quot;div&quot;).hide(); &#125;); &#125;)&lt;/script&gt;&lt;ul class=&quot;parentWrap&quot;&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题1&lt;/span&gt; &lt;div&gt;我是弹出来的div1&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题2&lt;/span&gt; &lt;div&gt;我是弹出来的div2&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题3&lt;/span&gt; &lt;div&gt;我是弹出来的div3&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;","tags":[]},{"title":"移动端饿了么首页轮播图数据请求","date":"2018-01-26T00:01:05.000Z","path":"2018/01/26/移动端饿了么首页轮播图数据请求/","text":"折腾了一个下午，终于实现了数据请求，使用的是express框架和axios 数据请求效果图：具体的实现过程如下：1.在谷歌浏览器下打开饿了么，调成手机模式，Network –&gt; XHR，查看具体的请求2.由上一步可知，请求的地址为：’https://h5.ele.me/restapi/shopping/openapi/entries‘具体的请求参数每个地区是不一样的，可在Query String Parammeters中查看（1）dev-server.js中添加：dev-server.js12345678910111213141516const axios = require(&apos;axios&apos;)var apiRoutes = express.Router()apiRoutes.get(&apos;/endata&apos;, function (req, res) &#123; var url =&apos;https://h5.ele.me/restapi/shopping/openapi/entries?latitude=23.6567&amp;longitude=116.622963&amp;templates[]=main_template&amp;templates[]=favourable_template&amp;templates[]=svip_template&apos; axios.get(url, &#123; headers: &#123; referer: &apos;https://h5.ele.me/&apos;, host: &apos;h5.ele.me&apos; &#125; &#125;).then((response) =&gt; &#123; res.json(response.data) &#125;).catch((e) =&gt; &#123; console.log(e) &#125;) &#125;)app.use(&apos;/api&apos;, apiRoutes)(2)vue中添加请求方法实现数据请求，使用es6的数组解构获取数据1234567891011121314created () &#123; this.entriesData()&#125;,methods: &#123; entriesData() &#123; axios.get(&apos;/api/endata&apos;).then((res) =&gt; &#123; if(res !== false)&#123; [this.entrie] = res.data this.entries = this.entrie console.log(this.entries) &#125; &#125;) &#125;&#125;,(3)entries就是请求下来的轮播图数据","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"es6笔记1","date":"2018-01-23T16:55:48.000Z","path":"2018/01/24/es6笔记1/","text":"es6可以参考阮一峰的教程，介绍了es6的编译方法和es6的语法，阮一峰：《ECMAScript 6 入门》 1.let和constes6新增用let声明变量，有如下的特点：(1)使用let声明的变量不能重复定义，下面这样的定义方式是不允许的12let a = 1;let a = 2; (2)声明的变量只在let命令所在的代码块内有效，简单的理解就是用{}包起来的作用域有效12345678function fun()&#123; for(let i=0;i&lt;5;i++)&#123; console.log(i) &#125; // 块级作用域之外无效 console.log(i)&#125;fun() (3)let声明的变量不存在变量提升,在定义之前使用报错：ReferenceError const:（1）用于声明一个常量,声明的常量不可以重复声明（2）声明的时候必须赋值，以下的情况会报错：12const RAD; RAD = 3.14 (3)const声明的有块级作用域123456789function test()&#123; for(let i=0;i&lt;3;i++)&#123; const bb = 'bb的值' &#125; // 都报错 console.log(i) console.log(bb)&#125;test() （4）const声明的对象的值可以改变，12345678910function test2()&#123; // 对象是引用类型的，k存储的是指针，对象本身是可以改变的 const obj=&#123; a:1 &#125; obj.b =3 //不报错 console.log(obj)&#125;test2() 2.解构赋值概念：解构赋值其实就是赋值，左边的对应右边的，一一对应进行赋值解构赋值的分类：（1）数组解构赋值（2）对象解构赋值（3）字符串解构赋值……需要重点理解的是数组结构赋值和对象解构赋值 数组解构赋值：1234567891011&#123; let a,b ,rest [a,b,...rest] = [1,2,3,4,5,6]; console.log(a,b,rest) //1 2 [3,4,5,6]&#125;&#123; let a,b,c,rest [a,b,c] =[1,2] // 没有找到配对的输出undefined console.log(a,b,c) //1 2 undefined&#125; 对象解构赋值：12345&#123; let a,b (&#123;a,b&#125; = &#123;a:1,b:2&#125;) console.log(a,b) // 1 2 &#125; 3.使用场景12345678910111213141516// 1、简单实现值的交换&#123; let a = 1; let b = 2; [a,b] = [b,a] console.log(a,b) 2,1&#125;//2、 获取返回的值&#123; function fun()&#123; return [1,2] &#125; let a,b [a,b] = fun() console.log(a,b)&#125; 123456789101112131415161718// 对象解构赋值的2边都是对象的形式// 按照 key value 的形式匹配// 嵌套取值&#123; let testData = &#123; title:'es6', test:[&#123; title:'es7', desc:'descript' &#125;] &#125; let &#123;title:esTitle,test:[&#123;title:cntitle&#125;]&#125; = testData console.log(esTitle,cntitle) //es6 es7 let &#123;title&#125; = testData console.log(title) // es6 let [test] = testData.test console.log(test.title) //es7&#125; ###3.字符串扩展es6中正则新增特性：（1）构造函数的变化（2）正则方法的扩展（3）u修饰符（4）y 修饰符 1、es5的写法：1234&#123; let regexp = new RegExp('axc','i') let regexp2 = new RegExp(/aass/i)&#125; 2、es6：1234567891011121314151617&#123; // 后面的修饰符可以覆盖前面的修饰符 let regexp3 = new RegExp(/ayz/ig,'i') // flags 是es6中新增加的，用来获取正则的修饰符 console.log(regexp3.flags) // i &#125;&#123; let s = 'bbb_bb_b' let a1 = /b+/g let a2 = /b+/y // g 和 y 都是全局匹配，但是y要从匹配好的下一个开始匹配，这里就是从_开始匹配，所以第二次的 y 匹配是null console.log('one',a1.exec(s),a2.exec(s)); console.log('two',a1.exec(s),a2.exec(s)); // 判断是否开启y修饰符 console.log(a1.sticky,a2.sticky) //false true&#125;","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vue项目使用express发送数据","date":"2018-01-22T16:44:39.000Z","path":"2018/01/23/vue项目使用express发送数据/","text":"之前使用vue-cli生成的项目中，是有express依赖的，后来的没有了，那怎样用express发送数据呢？研究了一下，实现的过程并不难 实现的过程如下：1.在生成的vue项目下，新建server文件夹，在server文件夹下，执行命令：123$ npm init$ cnpm install$ cnpm install express --save 2.在vue项目的根目录中放入需要的数据文件，我使用的datas.json文件3.在server文件夹下新建server.js文件：server.js123456789101112131415161718192021222324252627var appData = require(&apos;../datas.json&apos;)var list1 = appData.list1;var list2 = appData.list2;const express = require(&apos;express&apos;)const app = express()const apiRoutes = express.Router();apiRoutes.get(&apos;/list1&apos;,function(req,res)&#123; res.json(&#123; code:0, data:list1 &#125;);&#125;);apiRoutes.get(&apos;/list2&apos;,function(req,res)&#123; res.json(&#123; code:0, data:list2 &#125;);&#125;);app.use(&apos;/api&apos;,apiRoutes);app.listen(3000,function()&#123; console.log(&apos;server start&apos;);&#125;);4.在config文件夹下的index.js中设置代理：index.js12345678proxyTable: &#123; &apos;/api/list1&apos;:&#123; target:&apos;http://localhost:3000&apos; &#125;, &apos;/api/list2&apos;:&#123; target:&apos;http://localhost:3000&apos; &#125; &#125;,5.在server文件夹下执行：1node server.js完成前面的步骤，在vue项目中就可以使用axios请求数据了，如下：12345678910methods: &#123; getList1()&#123; axios.get(&apos;/api/list1&apos;).then((res) =&gt; &#123; if(res.data.code === 0)&#123; this.list1 = res.data.data console.log(this.list1) &#125; &#125;) &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"三栏布局的几种实现方式","date":"2018-01-22T15:41:02.000Z","path":"2018/01/22/三栏布局的几种实现方式/","text":"在高度已经知道的情况下，实现三栏布局，左栏、右栏的宽度为350px,中间部分自适应实现的效果图如下： 浮动的方式123456789101112131415161718192021222324252627/*css部分*/&#123; margin: 0; padding: 0;&#125;.left-center-right div&#123; min-height: 100px;&#125;.left-center-right .left&#123; float: left; width: 350px; background-color: red;&#125;.left-center-right .center&#123; background-color: green;&#125;.left-center-right .right&#123; background-color: blue; float: right; width: 350px;&#125;&lt;!-- 注意，此处的排列为left right center --&gt;&lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;左边部分&lt;/div&gt; &lt;div class=\"right\"&gt;右边部分&lt;/div&gt; &lt;div class=\"center\"&gt;中间部分&lt;/div&gt;&lt;/div&gt; 优点：兼容性好缺点：浮动的元素脱离标准流，需要清除浮动，处理不好就尴尬了 定位的方式123456789101112131415161718192021222324.left-center-right div&#123; min-height: 100px; position: absolute;&#125;.left-center-right .left&#123; left:0; width: 350px; background-color: red;&#125;.left-center-right .center&#123; left: 350px; right: 350px; background-color: green;&#125;.left-center-right .right&#123; right:0; background-color: blue; width: 350px;&#125;&lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;左边部分&lt;/div&gt; &lt;div class=\"right\"&gt;右边部分&lt;/div&gt; &lt;div class=\"center\"&gt;中间部分&lt;/div&gt;&lt;/div&gt; 优点：快速实现布局缺点：绝对定位的元素脱离标准流，子元素也需要脱离标准流，使用性比较差 flex布局的方式.left-right-center{ display: flex; } .left-right-center div{ min-height: 100px; } .left-right-center .left{ width: 300px; background-color: red; } .left-right-center .center{ flex:1; right: 300px; background-color: green; } .left-right-center .right{ width: 300px; background-color: blue; } 优点：css3的布局方式，可以简单的实现各种页面的响应式布局，特别是在移动端缺点： 表格布局的方式.left-right-center{ width:100%; display: table; height: 100px; } .left-right-center div{ display: table-cell; } .left{ width: 350px; background-color: red; } .center{ right: 350px; background-color: green; } .right{ background-color: blue; width: 300px; } 优点：实现简单，兼容性好缺点：一个高度变化的时候其他的也会撑高","tags":[{"name":"html/css","slug":"html-css","permalink":"http://yoursite.com/tags/html-css/"}]}]